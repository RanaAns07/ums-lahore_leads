// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// IDENTITY MODELS
// ============================================

/// Person represents immutable human identity data
/// This is the source of truth for who someone is
model Person {
  id            String    @id @default(uuid()) @db.Uuid
  legal_name    String
  date_of_birth DateTime  @db.Date
  gender        Gender
  nationality   String?
  
  created_at    DateTime  @default(now()) @db.Timestamptz
  updated_at    DateTime  @updatedAt @db.Timestamptz
  deleted_at    DateTime? @db.Timestamptz
  
  // Relations
  user                User?              // 1:1 relationship with User
  departments_headed  Department[]       @relation("DepartmentHead")
  course_offerings    CourseOffering[]   @relation("Instructor")
  inquiry_notes       InquiryNote[]      @relation("InquiryNoteActor")
  applications        Application[]      @relation("Applicant")
  student_profile     StudentProfile?    // 1:1 relationship with StudentProfile
  
  @@index([deleted_at])
  @@map("persons")
}

/// User represents authentication and system access credentials
/// Linked 1:1 with Person for complete user profile
model User {
  id                String    @id @default(uuid()) @db.Uuid
  person_id         String    @unique @db.Uuid
  email             String    @unique
  password_hash     String
  mfa_secret        String?
  status            UserStatus @default(PENDING_VERIFICATION)
  email_verified_at DateTime?  @db.Timestamptz
  last_login_at     DateTime?  @db.Timestamptz
  
  created_at        DateTime   @default(now()) @db.Timestamptz
  updated_at        DateTime   @updatedAt @db.Timestamptz
  deleted_at        DateTime?  @db.Timestamptz
  
  // Relations
  person            Person         @relation(fields: [person_id], references: [id], onDelete: Cascade)
  role_assignments  RoleAssignment[]
  refresh_tokens    RefreshToken[]
  audit_logs        AuditLog[]
  assigned_roles    RoleAssignment[] @relation("AssignedBy")
  
  @@index([email])
  @@index([status])
  @@index([deleted_at])
  @@map("users")
}

/// RefreshToken stores JWT refresh tokens for revocation
model RefreshToken {
  id         String    @id @default(uuid()) @db.Uuid
  user_id    String    @db.Uuid
  token      String    @unique
  expires_at DateTime  @db.Timestamptz
  revoked_at DateTime? @db.Timestamptz
  created_at DateTime  @default(now()) @db.Timestamptz
  
  // Relations
  user       User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  
  @@index([user_id])
  @@index([expires_at])
  @@map("refresh_tokens")
}

// ============================================
// RBAC MODELS
// ============================================

/// Role defines system roles (e.g., "admin", "student", "faculty")
model Role {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @unique
  description String?
  
  created_at  DateTime @default(now()) @db.Timestamptz
  updated_at  DateTime @updatedAt @db.Timestamptz
  
  // Relations
  role_permissions RolePermission[]
  role_assignments RoleAssignment[]
  
  @@map("roles")
}

/// Permission defines granular access rights (e.g., "student.read", "finance.write")
model Permission {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @unique // Full permission name: "resource.action"
  resource    String   // Resource name: "student", "finance"
  action      String   // Action: "read", "write", "delete"
  description String?
  
  created_at  DateTime @default(now()) @db.Timestamptz
  updated_at  DateTime @updatedAt @db.Timestamptz
  
  // Relations
  role_permissions RolePermission[]
  
  @@unique([resource, action])
  @@index([resource])
  @@map("permissions")
}

/// RolePermission links Roles to Permissions (many-to-many)
model RolePermission {
  role_id       String   @db.Uuid
  permission_id String   @db.Uuid
  
  created_at    DateTime @default(now()) @db.Timestamptz
  
  // Relations
  role          Role       @relation(fields: [role_id], references: [id], onDelete: Cascade)
  permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)
  
  @@id([role_id, permission_id])
  @@map("role_permissions")
}

/// RoleAssignment links Users to Roles with optional expiration
model RoleAssignment {
  id          String    @id @default(uuid()) @db.Uuid
  user_id     String    @db.Uuid
  role_id     String    @db.Uuid
  assigned_by String?   @db.Uuid // User who assigned this role
  assigned_at DateTime  @default(now()) @db.Timestamptz
  expires_at  DateTime? @db.Timestamptz
  
  // Relations
  user        User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  role        Role      @relation(fields: [role_id], references: [id], onDelete: Cascade)
  assigner    User?     @relation("AssignedBy", fields: [assigned_by], references: [id], onDelete: SetNull)
  
  @@unique([user_id, role_id])
  @@index([user_id])
  @@index([expires_at])
  @@map("role_assignments")
}

// ============================================
// AUDIT LOGGING
// ============================================

/// AuditLog captures all state-changing operations (CREATE, UPDATE, DELETE)
model AuditLog {
  id           String     @id @default(uuid()) @db.Uuid
  actor_id     String     @db.Uuid
  action       AuditAction
  subject_type String     // Model name: "User", "Person", "Role", etc.
  subject_id   String     @db.Uuid
  delta        Json       // JSONB: changed fields only for UPDATE, all fields for CREATE
  ip_address   String?
  user_agent   String?
  
  created_at   DateTime   @default(now()) @db.Timestamptz
  
  // Relations
  actor        User       @relation(fields: [actor_id], references: [id], onDelete: Cascade)
  
  @@index([actor_id])
  @@index([subject_type, subject_id])
  @@index([created_at])
  @@map("audit_logs")
}

// ============================================
// ENUMS
// ============================================

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  LOCKED
  PENDING_VERIFICATION
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

// ============================================
// ACADEMIC MODELS
// ============================================

/// Department represents an academic department within the university
model Department {
  id             String    @id @default(uuid()) @db.Uuid
  name           String
  code           String    @unique // e.g., "CS", "MATH"
  head_of_dept_id String?  @db.Uuid
  
  created_at     DateTime  @default(now()) @db.Timestamptz
  updated_at     DateTime  @updatedAt @db.Timestamptz
  
  // Relations
  head_of_dept   Person?   @relation("DepartmentHead", fields: [head_of_dept_id], references: [id], onDelete: SetNull)
  programs       Program[]
  courses        Course[]
  
  @@index([code])
  @@map("departments")
}

/// Program represents an academic degree program (e.g., BSCS, MSCS)
model Program {
  id                String   @id @default(uuid()) @db.Uuid
  name              String
  code              String   @unique // e.g., "BSCS", "MSEE"
  duration_semesters Int     // e.g., 8 for 4-year program
  department_id     String   @db.Uuid
  
  created_at        DateTime @default(now()) @db.Timestamptz
  updated_at        DateTime @updatedAt @db.Timestamptz
  
  // Relations
  department        Department    @relation(fields: [department_id], references: [id], onDelete: Cascade)
  inquiries         Inquiry[]
  applications      Application[]
  enrollments       Enrollment[]
  fee_structures    FeeStructure[]
  
  @@index([code])
  @@index([department_id])
  @@map("programs")
}

/// Course represents a course in the catalog (what is taught)
model Course {
  id            String   @id @default(uuid()) @db.Uuid
  name          String
  code          String   @unique // e.g., "CS201", "MATH101"
  credit_hours  Int
  department_id String   @db.Uuid
  
  created_at    DateTime @default(now()) @db.Timestamptz
  updated_at    DateTime @updatedAt @db.Timestamptz
  
  // Relations
  department    Department          @relation(fields: [department_id], references: [id], onDelete: Cascade)
  offerings     CourseOffering[]
  
  // Self-referencing for prerequisites
  prerequisites CoursePrerequisite[] @relation("CourseToPrerequisites")
  required_for  CoursePrerequisite[] @relation("PrerequisiteOf")
  
  @@index([code])
  @@index([department_id])
  @@map("courses")
}

/// CoursePrerequisite represents prerequisite relationships between courses
/// Self-referencing many-to-many
model CoursePrerequisite {
  course_id             String   @db.Uuid
  prerequisite_course_id String  @db.Uuid
  
  created_at            DateTime @default(now()) @db.Timestamptz
  
  // Relations
  course                Course   @relation("CourseToPrerequisites", fields: [course_id], references: [id], onDelete: Cascade)
  prerequisite_course   Course   @relation("PrerequisiteOf", fields: [prerequisite_course_id], references: [id], onDelete: Cascade)
  
  @@id([course_id, prerequisite_course_id])
  @@index([prerequisite_course_id])
  @@map("course_prerequisites")
}

/// Semester represents an academic term (when courses are taught)
model Semester {
  id         String   @id @default(uuid()) @db.Uuid
  name       String   // e.g., "Fall 2024", "Spring 2025"
  start_date DateTime @db.Date
  end_date   DateTime @db.Date
  is_active  Boolean  @default(false) // Only one can be true at a time
  
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz
  
  // Relations
  offerings  CourseOffering[]
  enrollments Enrollment[]
  fee_structures FeeStructure[]
  
  @@index([is_active])
  @@index([start_date])
  @@map("semesters")
}

/// CourseOffering represents a specific instance of a course in a semester
/// Links Course (what) with Semester (when) and Person (who teaches)
model CourseOffering {
  id            String   @id @default(uuid()) @db.Uuid
  course_id     String   @db.Uuid
  semester_id   String   @db.Uuid
  instructor_id String?  @db.Uuid // Nullable - allows unassigned offerings
  section_code  String   // e.g., "A", "B", "001"
  capacity      Int      // Maximum number of students
  
  created_at    DateTime @default(now()) @db.Timestamptz
  updated_at    DateTime @updatedAt @db.Timestamptz
  
  // Relations
  course        Course   @relation(fields: [course_id], references: [id], onDelete: Cascade)
  semester      Semester @relation(fields: [semester_id], references: [id], onDelete: Cascade)
  instructor    Person?  @relation("Instructor", fields: [instructor_id], references: [id], onDelete: SetNull)
  registrations CourseRegistration[]
  
  @@unique([course_id, semester_id, section_code])
  @@index([semester_id])
  @@index([instructor_id])
  @@map("course_offerings")
}

// ============================================
// ADMISSIONS MODELS
// ============================================

/// Inquiry represents a lead or potential student inquiry
model Inquiry {
  id         String        @id @default(uuid()) @db.Uuid
  first_name String
  last_name  String
  email      String        @unique
  phone      String?
  program_id String        @db.Uuid
  source     InquirySource
  status     InquiryStatus @default(NEW)
  
  created_at DateTime      @default(now()) @db.Timestamptz
  updated_at DateTime      @updatedAt @db.Timestamptz
  
  // Relations
  program      Program         @relation(fields: [program_id], references: [id], onDelete: Cascade)
  notes        InquiryNote[]
  applications Application[]
  
  @@index([email])
  @@index([status])
  @@index([program_id])
  @@map("inquiries")
}

/// InquiryNote provides immutable interaction history for inquiries
model InquiryNote {
  id                  String   @id @default(uuid()) @db.Uuid
  inquiry_id          String   @db.Uuid
  actor_id            String   @db.Uuid
  note_text           String?  @db.Text
  is_system_generated Boolean  @default(false)
  
  created_at          DateTime @default(now()) @db.Timestamptz
  
  // Relations
  inquiry             Inquiry  @relation(fields: [inquiry_id], references: [id], onDelete: Cascade)
  actor               Person   @relation("InquiryNoteActor", fields: [actor_id], references: [id], onDelete: Cascade)
  
  @@index([inquiry_id])
  @@index([actor_id])
  @@map("inquiry_notes")
}

/// Application represents a formal application to a program
model Application {
  id          String            @id @default(uuid()) @db.Uuid
  inquiry_id  String?           @db.Uuid
  person_id   String            @db.Uuid
  program_id  String            @db.Uuid
  batch_id    String            // e.g., "Fall-2024", "Spring-2025"
  status      ApplicationStatus @default(DRAFT)
  
  created_at   DateTime         @default(now()) @db.Timestamptz
  updated_at   DateTime         @updatedAt @db.Timestamptz
  submitted_at DateTime?        @db.Timestamptz
  reviewed_at  DateTime?        @db.Timestamptz
  
  // Relations
  inquiry   Inquiry?              @relation(fields: [inquiry_id], references: [id], onDelete: SetNull)
  person    Person                @relation("Applicant", fields: [person_id], references: [id], onDelete: Cascade)
  program   Program               @relation(fields: [program_id], references: [id], onDelete: Cascade)
  documents ApplicationDocument[]
  
  @@index([person_id])
  @@index([program_id])
  @@index([status])
  @@index([batch_id])
  @@map("applications")
}

/// ApplicationDocument represents uploaded documents for an application
model ApplicationDocument {
  id             String         @id @default(uuid()) @db.Uuid
  application_id String         @db.Uuid
  document_type  DocumentType
  file_url       String
  status         DocumentStatus @default(PENDING_REVIEW)
  
  created_at     DateTime       @default(now()) @db.Timestamptz
  updated_at     DateTime       @updatedAt @db.Timestamptz
  
  // Relations
  application    Application    @relation(fields: [application_id], references: [id], onDelete: Cascade)
  
  @@index([application_id])
  @@index([status])
  @@map("application_documents")
}

// ============================================
// ADMISSIONS ENUMS
// ============================================

enum InquirySource {
  WEB
  WALK_IN
  PHONE
  EMAIL
  REFERRAL
}

enum InquiryStatus {
  NEW
  CONTACTED
  IN_PROGRESS
  CONVERTED
  CLOSED
}

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  ACCEPTED
  REJECTED
  WAITLISTED
}

enum DocumentType {
  TRANSCRIPT
  ID_PROOF
  DEGREE_CERTIFICATE
  RECOMMENDATION_LETTER
  PERSONAL_STATEMENT
  OTHER
}

enum DocumentStatus {
  PENDING_REVIEW
  APPROVED
  REJECTED
}

// ============================================
// ENROLLMENT MODELS
// ============================================

/// StudentProfile represents a student's academic identity
model StudentProfile {
  id                String           @id @default(uuid()) @db.Uuid
  person_id         String           @unique @db.Uuid
  student_id_number String           @unique // Format: YYYY-DEPT-XXXX (e.g., 2024-CS-0001)
  status            EnrollmentStatus @default(PROVISIONED)
  
  created_at        DateTime         @default(now()) @db.Timestamptz
  updated_at        DateTime         @updatedAt @db.Timestamptz
  
  // Relations
  person            Person           @relation(fields: [person_id], references: [id], onDelete: Cascade)
  enrollments       Enrollment[]
  
  @@index([student_id_number])
  @@index([status])
  @@map("student_profiles")
}

/// Enrollment represents a student's enrollment in a specific program
model Enrollment {
  id                 String             @id @default(uuid()) @db.Uuid
  student_profile_id String             @db.Uuid
  program_id         String             @db.Uuid
  batch_id           String             // e.g., "Fall-2024", "Spring-2025"
  semester_id        String             @db.Uuid  // Enrollment semester (when they started)
  status             EnrollmentStatus   @default(PROVISIONED)
  
  created_at         DateTime           @default(now()) @db.Timestamptz
  updated_at         DateTime           @updatedAt @db.Timestamptz
  
  // Relations
  student_profile    StudentProfile     @relation(fields: [student_profile_id], references: [id], onDelete: Cascade)
  program            Program            @relation(fields: [program_id], references: [id], onDelete: Cascade)
  semester           Semester           @relation(fields: [semester_id], references: [id], onDelete: Cascade)
  registrations      CourseRegistration[]
  invoices           Invoice[]
  
  @@index([student_profile_id])
  @@index([program_id])
  @@index([batch_id])
  @@index([status])
  @@map("enrollments")
}

/// CourseRegistration represents a student's registration for a specific course offering
model CourseRegistration {
  id                 String             @id @default(uuid()) @db.Uuid
  enrollment_id      String             @db.Uuid
  course_offering_id String             @db.Uuid
  status             RegistrationStatus @default(REGISTERED)
  grade              String?            // Final grade (set after completion)
  
  created_at         DateTime           @default(now()) @db.Timestamptz
  updated_at         DateTime           @updatedAt @db.Timestamptz
  
  // Relations
  enrollment         Enrollment         @relation(fields: [enrollment_id], references: [id], onDelete: Cascade)
  course_offering    CourseOffering     @relation(fields: [course_offering_id], references: [id], onDelete: Cascade)
  
  @@unique([enrollment_id, course_offering_id]) // Student can only register once per offering
  @@index([enrollment_id])
  @@index([course_offering_id])
  @@index([status])
  @@map("course_registrations")
}

// ============================================
// ENROLLMENT ENUMS
// ============================================

enum EnrollmentStatus {
  PROVISIONED   // Created but pending payment/docs
  ACTIVE        // Fully enrolled and can register
  ON_HOLD       // Temporarily suspended
  WITHDRAWN     // Student withdrew
  GRADUATED     // Completed program
}

enum RegistrationStatus {
  REGISTERED    // Active registration
  DROPPED       // Student dropped the course
  COMPLETED     // Course completed
  FAILED        // Course failed
}

// ============================================
// FINANCE MODELS
// ============================================

/// FeeStructure defines fees for a program in a specific semester
model FeeStructure {
  id          String   @id @default(uuid()) @db.Uuid
  program_id  String   @db.Uuid
  semester_id String   @db.Uuid
  fee_type    FeeType
  amount      Decimal  @db.Decimal(10, 2)
  description String?
  
  created_at  DateTime @default(now()) @db.Timestamptz
  updated_at  DateTime @updatedAt @db.Timestamptz
  
  // Relations
  program     Program  @relation(fields: [program_id], references: [id], onDelete: Cascade)
  semester    Semester @relation(fields: [semester_id], references: [id], onDelete: Cascade)
  
  @@unique([program_id, semester_id, fee_type])
  @@index([program_id])
  @@index([semester_id])
  @@map("fee_structures")
}

/// Invoice represents a billing statement for an enrollment
model Invoice {
  id             String        @id @default(uuid()) @db.Uuid
  enrollment_id  String        @db.Uuid
  total_amount   Decimal       @db.Decimal(10, 2)
  paid_amount    Decimal       @default(0) @db.Decimal(10, 2)
  due_date       DateTime      @db.Date
  status         InvoiceStatus @default(UNPAID)
  
  created_at     DateTime      @default(now()) @db.Timestamptz
  updated_at     DateTime      @updatedAt @db.Timestamptz
  
  // Relations
  enrollment     Enrollment    @relation(fields: [enrollment_id], references: [id], onDelete: Cascade)
  items          InvoiceItem[]
  payments       Payment[]
  
  @@index([enrollment_id])
  @@index([status])
  @@index([due_date])
  @@map("invoices")
}

/// InvoiceItem represents a line item on an invoice
model InvoiceItem {
  id          String   @id @default(uuid()) @db.Uuid
  invoice_id  String   @db.Uuid
  fee_type    FeeType
  amount      Decimal  @db.Decimal(10, 2)
  description String
  
  created_at  DateTime @default(now()) @db.Timestamptz
  
  // Relations
  invoice     Invoice  @relation(fields: [invoice_id], references: [id], onDelete: Cascade)
  
  @@index([invoice_id])
  @@map("invoice_items")
}

/// Payment represents a payment transaction against an invoice
model Payment {
  id                    String        @id @default(uuid()) @db.Uuid
  invoice_id            String        @db.Uuid
  amount_paid           Decimal       @db.Decimal(10, 2)
  payment_method        String        // e.g., "CASH", "CARD", "BANK_TRANSFER"
  transaction_reference String?       // External reference number
  status                PaymentStatus @default(PENDING)
  notes                 String?       @db.Text
  
  created_at            DateTime      @default(now()) @db.Timestamptz
  updated_at            DateTime      @updatedAt @db.Timestamptz
  
  // Relations
  invoice               Invoice       @relation(fields: [invoice_id], references: [id], onDelete: Cascade)
  
  @@index([invoice_id])
  @@index([status])
  @@index([transaction_reference])
  @@map("payments")
}

// ============================================
// FINANCE ENUMS
// ============================================

enum FeeType {
  TUITION
  LAB
  ADMISSION
  LIBRARY
  SPORTS
  EXAMINATION
  HOSTEL
  TRANSPORTATION
  MISCELLANEOUS
}

enum InvoiceStatus {
  UNPAID    // No payments made
  PARTIAL   // Partially paid
  PAID      // Fully paid
  VOID      // Cancelled/voided
}

enum PaymentStatus {
  PENDING   // Payment initiated but not confirmed
  SUCCESS   // Payment successful
  FAILED    // Payment failed
}

// ============================================
// GENERAL LEDGER MODELS
// ============================================

/// Fund represents a university fund/account
model Fund {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @unique // e.g., "MAIN_RESERVE", "TUITION_POOL", "STUDENT_SOCIETY"
  balance     Decimal  @default(0) @db.Decimal(15, 2)
  description String?  @db.Text
  
  created_at  DateTime @default(now()) @db.Timestamptz
  updated_at  DateTime @updatedAt @db.Timestamptz
  
  // Relations
  transactions FinancialTransaction[]
  
  @@index([name])
  @@map("funds")
}

/// FinancialTransaction represents all money movements in/out of funds
model FinancialTransaction {
  id             String          @id @default(uuid()) @db.Uuid
  type           TransactionType
  fund_id        String          @db.Uuid
  amount         Decimal         @db.Decimal(15, 2)
  category       String          // e.g., "STUDENT_PAYMENT", "SALARY", "UTILITIES"
  reference_id   String?         @db.Uuid // InvoiceID, ExpenseID, etc.
  reference_type String?         // "Invoice", "Expense", "Adjustment"
  description    String          @db.Text
  
  created_at     DateTime        @default(now()) @db.Timestamptz
  
  // Relations
  fund           Fund            @relation(fields: [fund_id], references: [id], onDelete: Cascade)
  
  @@index([fund_id])
  @@index([type])
  @@index([category])
  @@index([reference_id])
  @@index([created_at])
  @@map("financial_transactions")
}

// ============================================
// LEDGER ENUMS
// ============================================

enum TransactionType {
  INFLOW   // Money coming in (revenue)
  OUTFLOW  // Money going out (expenses)
}
